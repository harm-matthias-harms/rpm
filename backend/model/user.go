package model

import (
	"errors"
	"regexp"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"golang.org/x/crypto/bcrypt"
)

var (
	emailRegex = "^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$"
)

// User is the type of a user
type User struct {
	ID       primitive.ObjectID `json:"id" form:"id" bson:"_id,omitempty"`
	Username string             `json:"username" form:"username" bson:"username"`
	Email    string             `json:"email" form:"email" bson:"email,omitempty"`
	Password string             `json:"password,omitempty" form:"password" bson:"password"`
	Code     string             `json:"code,omitempty" form:"code" bson:"code,omitempty"`
}

// LimitedUser describes a User with none vulnerable information
type LimitedUser struct {
	ID       primitive.ObjectID `json:"id" form:"id" bson:"_id" query:"id"`
	Username string             `json:"username" form:"password" bson:"username" query:"username"`
}

// ToLimitedUser offers the possibility to store the user to other documents without vulnerable data
func (user *User) ToLimitedUser() *LimitedUser {
	return &LimitedUser{ID: user.ID, Username: user.Username}
}

// Authenticate checks if the user is matching to the given password.
func (user *User) Authenticate(password string) error {
	return bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
}

// HashPassword hashes the users password for storing
func (user *User) HashPassword() error {
	password, err := bcrypt.GenerateFromPassword([]byte(user.Password), 14)
	if err != nil {
		return errors.New("can't hash password")
	}
	user.Password = string(password)
	return nil
}

// Validate validates alle field of the user have a valid form
func (user *User) Validate() (err error) {
	if err = user.validateUsername(); err != nil {
		return
	} else if err = user.validateEmail(); err != nil {
		return
	} else if err = user.validatePassword(); err != nil {
		return
	}
	return nil
}

func (user *User) validateUsername() error {
	if user.Username == "" {
		return errors.New("no username provided")
	} else if match, _ := regexp.MatchString("^[a-z1-9\\.]+$", user.Username); !match {
		return errors.New("username has wrong pattern")
	}
	return nil
}

func (user *User) validateEmail() error {
	// email is only needed if its is not an autogenerated user
	if user.Code == "" {
		if user.Email == "" {
			return errors.New("no email address provided")
		} else if match, _ := regexp.MatchString(emailRegex, user.Email); !match {
			return errors.New("email has wrong pattern")
		}
	}
	return nil
}

func (user *User) validatePassword() error {
	if user.Code == "" {
		if user.Password == "" {
			return errors.New("no password provided")
		} else if match, _ := regexp.MatchString("^\\S+$", user.Password); !match {
			return errors.New("password has whitespace")
		}
	}
	return nil
}
